<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="A case study on combining React and custom elements to balance complexity, improve maintainability, and enhance UI performance.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css" media="all">
    <title>âš–ï¸ Finding balance: bridging React and vanilla for a cleaner UI</title>
</head>
<body style="--bg: url('react-vanilla-bridge-bg.webp')">
    <header>
        <h1>âš–ï¸ Finding balance: bridging React and vanilla for a cleaner UI</h1>
        <p><strong>ğŸ“… Project year:</strong> 2024</p>
    </header>

    <section>
        <h2>ğŸš¨ The problem</h2>
        <p>React is excellent for <span class="highlight">view-as-a-function-of-state</span> UI, but not all UI components fit neatly into this model. Some UI elements work best with a <span class="highlight">more imperative, event-driven approach</span>, since many browser APIs are inherently imperative.</p>
        <p>Certain componentsâ€”like <span class="highlight">autocomplete, calendars, and toggletips</span>â€”were particularly difficult to implement cleanly in React. <span class="highlight">Toggletips</span>, for example, required <span class="highlight">delayed re-insertion of existing DOM nodes</span> to trigger screen readers, something impossible to do with React alone.</p>
        <p>React's declarative model <span class="highlight">clashed with imperative APIs</span>, making certain UI patterns difficult to implement efficiently.</p>
    </section>
    <section>
        <h2>âš ï¸ The challenges</h2>
        <ul>
            <li data-bullet="ğŸ”—">React's declarative model <span class="highlight">clashed with imperative APIs</span>, making certain UI patterns difficult to implement efficiently.</li>
            <li data-bullet="ğŸ“‰">The more components we built, the <span class="highlight">more adapter boilerplate</span> accumulated, increasing maintenance burden.</li>
            <li data-bullet="ğŸ› ï¸">Unnecessary re-renders impacted <span class="highlight">performance and UX</span>.</li>
            <li data-bullet="ğŸ”‘">The key was to <span class="highlight">find a natural transition point between Reactâ€™s declarative model and imperative UI interactions</span>. Without a structured approach, integrating these two paradigms became a significant challenge.</li>
            <li data-bullet="ğŸ”„">React's poor support for custom elements required creative workarounds, such as a roundabout way to trigger native events and a custom hook for listening to custom events.</li>
        </ul>
    </section>
    <section>
        <h2>ğŸ’¡ The solution</h2>
        <ul>
            <li data-bullet="ğŸš€">Encapsulated <span class="highlight">imperative behavior</span> inside custom elements, keeping React clean.</li>
            <li data-bullet="ğŸ”§">React used custom elements <span class="highlight">just like native HTML elements</span>, eliminating unnecessary adapter code.</li>
            <li data-bullet="âš¡">State was stored <span class="highlight">directly in the DOM</span>, completely eliminating unnecessary re-renders.</li>
            <li data-bullet="ğŸŒ">The same custom elements were <span class="highlight">usable in traditional server-rendered pages</span>, making the UI <span class="highlight">framework-agnostic</span>.</li>
        </ul>
    </section>
    <section>
        <h2>ğŸ“ˆ The impact</h2>
        <p>By bridging React with custom elements, we created a more <span class="highlight">flexible, maintainable, and performant</span> UI architecture.</p>
        <ul class="impact">
            <li><span class="highlight">Reduced boilerplate code</span>, making development <span class="highlight">faster and cleaner</span>.</li>
            <li><span class="highlight">Improved performance</span> by <span class="highlight">eliminating unnecessary React re-renders</span>.</li>
            <li><span class="highlight">Unified component usage</span> across both <span class="highlight">React and traditional server-rendered pages</span>.</li>
            <li><span class="highlight">Saved thousands of lines of code</span> by leveraging simpme in-house code over heavy 3rd party libraries.</li>
            <li><span class="highlight">Simplified dependency management</span>, making future React upgrades painless by removing outdated, framework-dependent libraries.</li>
        </ul>
        <p>This approach provided the <span class="highlight">best of both worlds</span>â€”leveraging React where it shines while using native DOM capabilities where theyâ€™re most effective.</p>
    </section>
    <section>
        <h2>ğŸ“ The lessons learned</h2>
        <ul>
            <li data-bullet="âš–ï¸"><span class="highlight">Balancing declarative and imperative code</span> leads to cleaner, more efficient UIs.</li>
            <li data-bullet="ğŸ”"><span class="highlight">Not everything needs to be in React</span>â€”often, native browser features are the best tool for the job.</li>
            <li data-bullet="ğŸŒ"><span class="highlight">Framework-agnostic design future-proofs your UI</span>, making it easier to integrate across different architectures.</li>
        </ul>
    </section>
    
    <footer>
        <p><a href="./">ğŸ”™ Back to portfolio</a></p>
        <p><a href="https://www.linkedin.com/in/hajime-yamasaki-vukelic/">Want to simplify your UI architecture? Let's talk.</a></p>
    </footer>
</body>
</html>
